# Using The Example walker.js Configuration in GTM
The code contained in `example-init-tag.html` can be used as a starting point for loading and implementing the walker.js library using a Custom HTML tag inside Google Tag Manager. 

Copy the code and add it to a new tag that can either be fired on every page whenever there is consent. Do not forget to change the endpoint URL and path to walker.js. The setup is based on the sample implementation / configuration in `walker-init.js` from the ssGTM client template repository [here](https://github.com/elbwalker/sgtm-client-template/tree/main/example#readme).

## Handling Consent
This example code replicates the usage of *localStorage* and *sessionStorage* for keeping track of a device id, a session id and session numbers (neccessary for GA4) like demonstrated in `walker-init.js` in the ssGTM example. You will have to adopt this part of the code to use your own implementation for persistent values like cookies or at least add the keys used in this example to your privacy information, consent dialog or similar. 

### Use Destination
A different approach would be to add consent-sensitivity to the walker.js destination and let walker.js know when there is consent. More info about consent handling can be found in the [elbwalker docs](https://docs.elbwalker.com/privacy/consent). The example `walker-init.js` from the ssGTM client template shows how to handle consent for different destinations and has a "marketing" destination that only fires if consent is granted. 

Adding events to the `elbLayer` (using code or the client template from this repository) then can be done without fear of sending events to your endpoint when the user opts out (or has not yet made a choice).

### Use Triggers
If you already have an existing implementation, all triggers needed for respecting consent are most likely already available. You can add walker.js tags as an addition to or replacement for your existing tag (like Universal Analytics or GA4). 

### Let The Server Decide
The simple example for the [server-side GTM client template](https://github.com/elbwalker/sgtm-client-template/tree/main/example#readme) sends every event to ssGTM and just adds persistent user information and parameters about the session if consent is granted. Otherwise, events with a reduced amount of information still get sent to the server. Every event contains information about the consent state. You can replicate this concept and add triggers to your ssGTM tags that only fire if there is consent (and all information needed for the service is available in the events).     

## Sending Events
Events can be created using the tag template from this repository. Firing can occur before or after walker configuration or the destination gets activated by a new consent state (when using a consent sensitive destination)

### Send Events Manually
As an alternative, all events can be generated by using regular Custom HTML tags in GTM instead of the event template. Just use the `elb()` function described in the [elbwalker docs](https://docs.elbwalker.com/tagging/using-javascript). 

Having all values for attributes like `transaction_id`, `value`, `currency` and e-commerce `items` available as dataLayer variables in an existing implementation can use those variables to send a purchase with the following code as an option to using the event template (which might be useful if an HTML tag serves multiple purposes).

```
<script>
  var elb = elb || function () {(window.elbLayer = window.elbLayer || []).push(arguments);}
  elb("order success", 
      {
        transaction_id: {{ecommerce.transaction_id}},
        tax: {{ecommerce.tax}},
        shipping: {{ecommerce.shipping}},
        value: {{ecommerce.value}},
        currency: {{ecommerce.currency}}  
      }, 
      "load",
      {event_name: "purchase"}, 
      {{convert2nested}}({{ecommerce.items}})
  );  
</script>
```

This code uses (along with standard dataLayer variables for e-commerce values that possibly exist with different variable names) a reference to a *function variable* called **convert2nested** that allows the conversion of GA4 `items` to the walker.js `nested` format. Create a variable with that name and the following code if you want to use the function yourself: 

```
function() {
  return function(eec) {
    var src = eec;
    if (!eec || typeof(eec) !== "object") return [];
    //do we have items / products or a complete ecommerce object?
    if (eec.ecommerce && eec.ecommerce.items) 
      src = eec.ecommerce.items; 
    else 
      if (eec.items) src = eec.items; 
    if (!src || !Array.isArray(src)) return [];
    try {   
      return src.map(function(x){
        return {
          type: "product",
          data: x
        }
      });
    } catch(e) {
      return [];
    }  
  }  
}
```

Calling the function with ecommerce.items or any other object containing `ecommerce.items` or an `items` key as argument will return a converted array that fits the walker.js `nested` format.

This function does exactly the same as the option *Convert E-Commerce Items To "nested" Format* in the event tag template. Even when using the event tag template, you still might want to use this function in an extended version that converts Universal Analytics e-commerce dataLayers and then feed the `nested` array from the tag template using a converted e-commerce object.    